{% extends 'base.html' %}

{% block title %}Stress ‚Äî Game{% endblock %}



{% block content %}
<div class="game-box" style="position:relative; padding:20px;">
<a href="{{ url_for('stress.tables') }}" class="game-tile-btn">
  üéÆ Stress
</a>



<style>
  /* Theme-aware tile button */
  .game-tile-btn{
    position:absolute; top:20px; left:20px;
    display:flex; align-items:center; justify-content:center;
    width:90px; height:90px; border-radius:12px;
    text-decoration:none; font-size:20px;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
    border:1px solid;
  }
  body.dark-mode .game-tile-btn{
    background:#0b1220; color:#e5e7eb; border-color:#2b2f36;
  }
  body:not(.dark-mode) .game-tile-btn{
    background:#e9eef3; color:#111827; border-color:#cbd5e1;
  }
</style>


<style>
  /* --- Dark-mode enforcement for everything inside the game mount --- */
  /* Light defaults (do nothing special here; your module keeps its own styles) */

  /* Dark mode: force readable colors inside the game tree */
  body.dark-mode #gx-root,
  body.dark-mode #gx-root * {
    color: #e5e7eb !important;
    border-color: #2b2f36 !important;
  }

  /* Give common container elements a dark surface so backgrounds don‚Äôt stay light */
  body.dark-mode #gx-root div,
  body.dark-mode #gx-root section,
  body.dark-mode #gx-root article,
  body.dark-mode #gx-root aside,
  body.dark-mode #gx-root header,
  body.dark-mode #gx-root footer {
    background-color: #0b1220 !important;
  }

  /* Buttons stay branded but readable */
  body.dark-mode #gx-root button {
    background-color: #2563eb !important;
    color: #ffffff !important;
  }

  /* Cards / piles often need a slightly lighter surface than the panel */
  body.dark-mode #gx-root .card,
  body.dark-mode #gx-root .pile {
    background-color: #1f2937 !important;
  }
</style>



<style>
  /* === Theme hooks for the Stress game mounted in #gx-root === */

  /* inherit text color */
  #gx-root { color: var(--text); }

  /* Common surfaces in the game UI (broad selectors on purpose) */
  #gx-root .board,
  #gx-root .panel,
  #gx-root .hud,
  #gx-root .box,
  #gx-root .surface,
  #gx-root .controls {
    background: var(--chat-bg);
    color: var(--text);
    border-radius: 10px;
  }

  /* Cards / piles (light defaults) */
  #gx-root .card,
  #gx-root .pile {
    background: #faecd5;
    border: 2px solid #1f2937;
    border-radius: 10px;
    color: #111827;
  }

  /* Hint / notice bar (light) */
  #gx-root .hint,
  #gx-root .notice {
    background: #dbeafe;
    color: #111827;
    border: 1px solid #bfdbfe;
    border-radius: 8px;
    padding: 8px 12px;
  }

  /* Primary buttons (keep brand color) */
  #gx-root .btn,
  #gx-root button {
    background: #2563eb;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 8px 16px;
    cursor: pointer;
  }
  #gx-root .btn:disabled,
  #gx-root button:disabled { opacity: .6; cursor: default; }

  /* === Dark-mode variants === */
  body.dark-mode #gx-root .board,
  body.dark-mode #gx-root .panel,
  body.dark-mode #gx-root .hud,
  body.dark-mode #gx-root .box,
  body.dark-mode #gx-root .surface,
  body.dark-mode #gx-root .controls {
    background: #0b1220;
    color: #e5e7eb;
    border-color: #2b2f36;
  }

  body.dark-mode #gx-root .card,
  body.dark-mode #gx-root .pile {
    background: #1f2937;
    border-color: #374151;
    color: #e5e7eb;
  }

  body.dark-mode #gx-root .hint,
  body.dark-mode #gx-root .notice {
    background: #0b1220;
    color: #e5e7eb;
    border-color: #2b2f36;
  }
</style>




  <!-- Mount point for your games module -->
  <div id="gx-root" style="margin-top:140px;"></div>
</div>






<div class="chat-box" style="display:none">
<div class="container">
<div class="sidebar">
<div class="users">
<h3>Online Users</h3>
<ul id="users"></ul>
</div>
<div class="emojis">
<h3>Emojis</h3>
<div id="emoji-buttons">
<button type="button">‚ù§Ô∏è</button>
<button type="button">üëç</button>
<button type="button">üòÄ</button>
<button type="button">üòÇ</button>
<button type="button">üòé</button>
<button type="button">üéâ</button>
</div>
<br>
<input type="file" id="imageUpload" accept="image/*">
</div>
</div>

<div class="chat-area" id="chatbox">
{% for message in messages %}
<div class="chat-message" data-id="{{ message.id }}">
<span>
{{ message.timestamp.strftime('%H:%M') }} - <strong>{{ message.username }}</strong>

{% if message.username in muted %}
<span class="muted-label">(muted)</span>
{% endif %}: {{ message.text.replace('\n', '<br>')|safe }}

</span>
{% if is_mod %}
<span class="admin-controls">
<button onclick="deleteMessage({{ message.id }})">üóëÔ∏è</button>
</span>
{% endif %}
</div>
{% endfor %}
<script>
const chatMessages = document.querySelectorAll('.chat-message');
if (chatMessages.length > 0) {
const firstMsgId = chatMessages[0].dataset.id;
window.oldestMessageId = parseInt(firstMsgId);
}
</script>

</div>

<div class="input-area">
<div class="typing-indicator" id="typing-indicator"></div>
<form id="chat-form">
<textarea id="message" placeholder="Type a message..." required autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
<button type="submit">Send</button>
</form>
</div>
</div>
</div>
</div>

<div class="popup" id="popup"></div>

<!-- Pass is_mod to JS -->
<script>
document.body.dataset.username = "{{ username }}";
document.body.dataset.isMod = "{{ 'true' if is_mod else 'false' }}";
</script>
{% endblock %}




{% block scripts %}





<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- Guard: if there is no chat UI on this page, skip all chat JS ---
  if (!document.getElementById('chatbox') || 
      !document.getElementById('chat-form') || 
      !document.getElementById('message')) {
    return;
  }

let oldestMessageId = window.oldestMessageId || null;

let loadingOlderMessages = false;

const socket = io();
const ROOM = "{{ room|default('') }}";

// If we're on a room page, auto-join that Socket.IO room
if (ROOM) {
  socket.on("connect", () => {
    socket.emit("join_room", {
      room: ROOM,
      username: document.body.dataset.username || "{{ username }}"
    });
  });
}

const chatbox = document.getElementById('chatbox');
const form = document.getElementById('chat-form');
const messageInput = document.getElementById('message');
const typingIndicator = document.getElementById('typing-indicator');
const popup = document.getElementById('popup');
const imageUpload = document.getElementById('imageUpload');

chatbox.scrollTop = chatbox.scrollHeight;
chatbox.addEventListener('scroll', () => {
if (chatbox.scrollTop === 0 && !loadingOlderMessages && oldestMessageId) {
loadingOlderMessages = true;
fetch(`/load_more?before_id=${oldestMessageId}`)
.then(res => res.json())
.then(olderMessages => {
if (olderMessages.length === 0) {
console.log("No older messages to load.");
return;
}

const prevScrollHeight = chatbox.scrollHeight;

olderMessages.forEach(msg => {
const div = document.createElement('div');
div.className = 'chat-message';
div.dataset.id = msg.id;

let formattedText = msg.text.replace(/\n/g, "<br>");
let inner = `<span>${msg.timestamp} - <strong>${msg.username}</strong>: ${formattedText}</span>`;


if (document.body.dataset.isMod === 'true') {
inner += `<span class="admin-controls">
                       <button onclick="deleteMessage(${msg.id})">üóëÔ∏è</button>
                     </span>`;
}
div.innerHTML = inner;
chatbox.insertBefore(div, chatbox.firstChild);

if (!oldestMessageId || msg.id < oldestMessageId) {
oldestMessageId = msg.id;
}
});

const newScrollHeight = chatbox.scrollHeight;
chatbox.scrollTop = newScrollHeight - prevScrollHeight;
})
.catch(err => console.error("Failed to load older messages:", err))
.finally(() => {
loadingOlderMessages = false;
});
}
});


socket.on('update_users', (users, isMod, mutedList) => {
const userList = document.getElementById('users');
userList.innerHTML = '';
users.forEach(userObj => {
const li = document.createElement('li');
const emoji = userObj.afk ? 'üî¥' : 'üü¢';
const dot = document.createElement('span');
dot.className = 'status-dot emoji-dot';
dot.textContent = emoji;
dot.title = userObj.afk ? 'AFK' : 'Online';
dot.style.marginRight = '12px';  // ‚Üê ‚úÖ add spacing
dot.style.marginRight = '10px';  // ‚Üê ‚úÖ add spacing
li.appendChild(dot);


li.appendChild(document.createTextNode(userObj.name));

if (mutedList.includes(userObj.name)) {
const mutedSpan = document.createElement('span');
mutedSpan.className = 'muted-label';
mutedSpan.textContent = ' (muted)';
li.appendChild(mutedSpan);
}

if (document.body.dataset.isMod === 'true' && userObj.name !== document.body.dataset.username) {
const btn = document.createElement('button');
btn.className = 'mute-btn';
btn.textContent = mutedList.includes(userObj.name) ? 'üîä' : 'üîá';
btn.onclick = () => {
socket.emit(mutedList.includes(userObj.name) ? 'unmute_user' : 'mute_user', userObj.name);
};
li.appendChild(btn);
}


userList.appendChild(li);
});
});

socket.on('typing', (username) => {
typingIndicator.textContent = `${username} is typing...`;
});

socket.on('stop_typing', () => {
typingIndicator.textContent = '';
});

messageInput.addEventListener('input', () => {
socket.emit('typing');
clearTimeout(window.typingTimeout);
window.typingTimeout = setTimeout(() => {
socket.emit('stop_typing');
}, 1000);
});

messageInput.addEventListener('keydown', (e) => {
if (e.key === 'Enter' && !e.shiftKey) {
e.preventDefault();
form.requestSubmit();
}
});

form.addEventListener('submit', (e) => {
e.preventDefault();
const msg = messageInput.value.trim();
if (msg) {
  if (ROOM) {
    // New room-scoped event
    socket.emit('chat_message', {
      room: ROOM,
      username: document.body.dataset.username || "{{ username }}",
      message: msg
    });
  } else {
    // Legacy/global event
    socket.emit('chat', msg);
  }
  messageInput.value = '';
  socket.emit('stop_typing');
}

});


// Room-scoped message listener (new)
// Server should emit "chat_message" to a specific room
socket.on("chat_message", (data) => {
  const div = document.createElement('div');
  div.className = 'chat-message';
  div.dataset.id = data.id || "";

  let formattedText = (data.message || data.text || "").replace(/\n/g, "<br>");
  let inner = `<span>${data.timestamp || ''} - <strong>${data.username || 'Unknown'}</strong>: ${formattedText}</span>`;

  if (document.body.dataset.isMod === 'true' && data.id) {
    inner += `<span class="admin-controls"><button onclick="deleteMessage(${data.id})">üóëÔ∏è</button></span>`;
  }
  div.innerHTML = inner;
  chatbox.appendChild(div);
  chatbox.scrollTop = chatbox.scrollHeight;
  showPopup(`${data.username || 'Someone'} sent a message`);
});


socket.on('chat', (data) => {
const div = document.createElement('div');
div.className = 'chat-message';
div.dataset.id = data.id;
if (!oldestMessageId || data.id < oldestMessageId) {
oldestMessageId = data.id;
}

let formattedText = data.text.replace(/\n/g, "<br>");
let inner = `<span>${data.timestamp} - <strong>${data.username}</strong>: ${formattedText}</span>`;


if (document.body.dataset.isMod === 'true') {
inner += `<span class="admin-controls"><button onclick="deleteMessage(${data.id})">üóëÔ∏è</button></span>`;
}
div.innerHTML = inner;
chatbox.appendChild(div);
chatbox.scrollTop = chatbox.scrollHeight;
showPopup(`${data.username} sent a message`);
});

socket.on('remove_message', (msgId) => {
console.log("[CLIENT] Received remove_message for ID:", msgId);
const msgEl = document.querySelector(`.chat-message[data-id='${msgId}']`);
if (msgEl) {
console.log("[CLIENT] Found matching element, removing.");
msgEl.remove();
} else {
console.warn("[CLIENT] No element found with data-id =", msgId);
}
});


function deleteMessage(id) {
console.log("[CLIENT] Deleting message:", id);
socket.emit('delete_message', id);
}
window.deleteMessage = deleteMessage;


function showPopup(text) {
popup.textContent = text;
popup.classList.add('show');
setTimeout(() => popup.classList.remove('show'), 3000);
}

document.querySelectorAll('#emoji-buttons button').forEach(btn => {
btn.addEventListener('click', () => {
const emoji = btn.textContent;
const input = messageInput;
const start = input.selectionStart;
const end = input.selectionEnd;
const text = input.value;
input.value = text.slice(0, start) + emoji + text.slice(end);
input.focus();
input.setSelectionRange(start + emoji.length, start + emoji.length);
});
});

imageUpload.addEventListener('change', () => {
const file = imageUpload.files[0];
if (file) {
const reader = new FileReader();
reader.onload = function(e) {
socket.emit('chat', `<img src='${e.target.result}' style='max-width:200px;'>`);
};
reader.readAsDataURL(file);
}
});
});
</script> <!-- ‚Üê this closes your chat script -->

<script type="module">
  const mountSelector = '#gx-root';
  const username = document.body.dataset.username || "{{ username }}";
  const isDark = () => document.body.classList.contains('dark-mode');

  function pickAPI(mod) {
    // Prefer global if a UMD/IIFE bundle registered it
    if (window.XeriGames && typeof window.XeriGames.mount === 'function') return window.XeriGames;
    // ES module default export
    if (mod?.default && typeof mod.default.mount === 'function') return mod.default;
    // ES module named export
    if (mod && typeof mod.mount === 'function') return mod;
    return null;
  }

  async function importModule(path) {
    try {
      const mod = await import(path + `?v=${Date.now()}`); // cache-bust
      console.log('[Xeri] Imported module:', path, mod);
      return pickAPI(mod);
    } catch (e) {
      console.warn('[Xeri] ESM import failed for', path, e);
      return null;
    }
  }

  function loadClassic(path) {
    return new Promise(resolve => {
      const s = document.createElement('script');
      s.src = path + `?v=${Date.now()}`;
      s.async = true;
      s.onload = () => resolve(pickAPI(null));
      s.onerror = () => resolve(null);
      document.head.appendChild(s);
    });
  }

  async function loadAndMount() {
    // Try the ESM bundle first
    let api =
      await importModule("{{ url_for('static', filename='games/games.module.js') }}") ||
      await importModule("{{ url_for('static', filename='games/stress/stress.js') }}");

    // Fallback to classic script loading if no ESM exports
    if (!api) {
      api =
        await loadClassic("{{ url_for('static', filename='games/games.module.js') }}") ||
        await loadClassic("{{ url_for('static', filename='games/stress/stress.js') }}");

      // As a last resort, wait a moment for a global to appear
      if (!api) {
        for (let i = 0; i < 10 && !api; i++) {
          await new Promise(r => setTimeout(r, 150));
          if (window.XeriGames && typeof window.XeriGames.mount === 'function') {
            api = window.XeriGames;
          }
        }
      }
    }

    if (!api || typeof api.mount !== 'function') {
      console.error('‚ùå Could not find XeriGames.mount(). Check which bundle exports it.');
      return;
    }

    api.mount(mountSelector, {
      username,
      theme: isDark() ? 'dark' : 'light'
    });

    if (typeof api.setTheme === 'function') {
      new MutationObserver(() => api.setTheme(isDark() ? 'dark' : 'light'))
        .observe(document.body, { attributes: true, attributeFilter: ['class'] });
    }
  }

  loadAndMount();
</script>


{% endblock %}